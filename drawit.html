<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Shooter — Nitish's Game Zone</title>
<style>
  :root{
    --bg1:#02021a;
    --bg2:#071230;
    --accent:#33ffe6;
    --muted:#9fb4c8;
  }
  html,body{height:100%;margin:0;font-family:Inter, Poppins, system-ui, -apple-system, "Segoe UI", Roboto;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6eef8}
  /* topbar fixed */
  .topbar{
    position:fixed;left:0;right:0;top:0;height:56px;display:flex;align-items:center;justify-content:space-between;padding:8px 12px;gap:8px;
    z-index:120;background:linear-gradient(180deg,rgba(0,0,0,0.35),rgba(0,0,0,0.12));backdrop-filter:blur(6px);box-shadow:0 8px 24px rgba(0,0,0,0.5)
  }
  .left,.right{display:flex;gap:8px;align-items:center}
  .scoreBox{background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:var(--accent);font-weight:800}
  .btn{border:none;padding:8px 12px;border-radius:10px;cursor:pointer;background:linear-gradient(90deg,#6a5cff,#9b7bff);color:white;font-weight:800;box-shadow:0 10px 24px rgba(107,90,255,0.06)}
  .btn.secondary{background:linear-gradient(90deg,#ff7a7a,#ffb27a)}
  /* game area under topbar */
  #area{position:absolute;left:0;right:0;top:56px;bottom:0;overflow:hidden}
  canvas{display:block;width:100%;height:100%}
  /* UI overlay for mobile */
  .hud{
    position:fixed;left:12px;bottom:12px;z-index:140;display:flex;gap:8px;pointer-events:none
  }
  .fireBtn{
    pointer-events:auto;
    width:72px;height:72px;border-radius:999px;background:linear-gradient(180deg,#ff5252,#ff7979);border:none;color:white;font-weight:900;
    box-shadow:0 12px 30px rgba(255,80,80,0.25);font-size:18px;
  }
  .controlsGuide{pointer-events:none;color:rgba(255,255,255,0.7);font-size:13px;margin-left:8px}
  .overlayPanel{position:fixed;inset:56px 0 0 0;display:flex;align-items:center;justify-content:center;z-index:200;pointer-events:none}
  .panel{pointer-events:auto;background:#ffffff;min-width:260px;padding:18px;border-radius:12px;color:#031a2b;box-shadow:0 20px 60px rgba(0,0,0,0.4);text-align:center}
  footer{position:fixed;left:0;right:0;bottom:6px;text-align:center;color:var(--muted);z-index:130}
  @media (max-width:520px){ .topbar{height:52px} }
</style>
</head>
<body>
  <div class="topbar">
    <div class="left">
      <div class="scoreBox" id="scoreBox">Score: 0</div>
      <div style="background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;font-weight:700">High: <span id="highBox">0</span></div>
    </div>
    <div class="right">
      <button class="btn secondary" id="pauseBtn">Pause</button>
      <button class="btn" id="restartBtn">Restart</button>
      <button class="btn secondary" id="homeBtn">Return to Dashboard</button>
    </div>
  </div>

  <div id="area">
    <canvas id="gameCanvas" aria-label="Space shooter game canvas"></canvas>

    <!-- HUD: Fire button for mobile -->
    <div class="hud">
      <button id="fireBtn" class="fireBtn" title="Hold to auto-fire">FIRE</button>
      <div class="controlsGuide">Drag ship • Hold FIRE to shoot</div>
    </div>

    <!-- overlay panel -->
    <div class="overlayPanel" id="overlayPanel" style="display:none">
      <div class="panel">
        <div style="font-size:20px;font-weight:900" id="panelTitle">Game Over</div>
        <div style="margin-top:8px" id="panelText">Your ship was destroyed.</div>
        <div style="font-size:22px;font-weight:900;margin-top:12px">Score: <span id="panelScore">0</span></div>
        <div style="display:flex;gap:10px;justify-content:center;margin-top:12px">
          <button class="btn" id="playAgain">Play Again</button>
          <button class="btn secondary" id="panelHome">Dashboard</button>
        </div>
      </div>
    </div>

  </div>

  <footer>Designed by Nitish Agrawal | All rights reserved © 2025</footer>

<script>
/* Space Shooter — single-file game
 Controls:
  - Drag ship horizontally (pointer) or use ArrowLeft/Right
  - Hold FIRE button (or hold mouse / hold space) to auto-fire bullets
  - Restart / Pause / Return to Dashboard available in topbar
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const area = document.getElementById('area');
const scoreBox = document.getElementById('scoreBox');
const highBox = document.getElementById('highBox');
const overlayPanel = document.getElementById('overlayPanel');
const panelTitle = document.getElementById('panelTitle');
const panelText = document.getElementById('panelText');
const panelScore = document.getElementById('panelScore');

let DPR = window.devicePixelRatio || 1;
function resize(){
  const w = Math.max(320, area.clientWidth);
  const h = Math.max(320, area.clientHeight);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * DPR);
  canvas.height = Math.floor(h * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  gameW = w; gameH = h;
}
window.addEventListener('resize', resize);
resize();

let gameW = canvas.clientWidth, gameH = canvas.clientHeight;

// Game state
let running = true;
let paused = false;
let score = 0;
let highScore = Number(localStorage.getItem('space_high')||0);
highBox.textContent = highScore;

// Player ship
const player = {
  x: gameW / 2,
  y: gameH - 80,
  w: 48,
  h: 54,
  hp: 3,
  speed: 8,
  dragging: false,
  offsetX:0
};

// Pools
let bullets = [];      // player bullets
let enemyBullets = []; // bullets shot by enemies
let enemies = [];      // enemy objects
let particles = [];    // explosion particles

// Timers
let lastSpawn = 0;
let spawnInterval = 1400; // ms, decreases with score
let lastTime = 0;
let fireHold = false;   // whether fire button is held
let lastShot = 0;
const SHOT_COOLDOWN = 180; // ms between player shots

// Audio (simple)
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioCtx ? new AudioCtx() : null;
function playShot(){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.value = 880;
  g.gain.value = 0.0001;
  g.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.16);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + 0.17);
}
function playExplosion(){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sawtooth';
  o.frequency.setValueAtTime(240, audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.3);
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.4, audioCtx.currentTime+0.02);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.5);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + 0.5);
}

// Utility
function rand(a,b){ return Math.random()*(b-a)+a; }

// Spawn enemies
function spawnEnemy(){
  // enemy types: small (fast), medium (shoot), big (hp)
  const r = Math.random();
  let type = 'small';
  if (r > 0.85) type = 'big';
  else if (r > 0.6) type = 'medium';
  const x = rand(40, gameW - 40);
  const y = -40;
  const speed = type === 'small' ? rand(1.8,3.2) : (type==='medium'? rand(1.2,2.0) : rand(0.6,1.2));
  const hp = type==='big' ? 3 : 1;
  enemies.push({ x,y,speed,type,hp, wob: rand(0,Math.PI*2), shootTimer: rand(1000,2200) });
}

// Shooting helpers
function playerShoot(){
  const now = performance.now();
  if (now - lastShot < SHOT_COOLDOWN) return;
  lastShot = now;
  bullets.push({ x: player.x, y: player.y - player.h/2 - 6, vx:0, vy:-8, ttl:2000 });
  playShot();
}

function enemyShoot(e){
  // enemy shoots a bullet towards player
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const ang = Math.atan2(dy, dx);
  const speed = 3.6;
  enemyBullets.push({ x: e.x, y: e.y + 12, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, ttl:4000 });
}

// Particles for explosion
function spawnExplosion(x,y,color,count=12){
  playExplosion();
  for(let i=0;i<count;i++){
    const a = rand(0, Math.PI*2);
    const s = rand(1.6, 4.2);
    particles.push({ x,y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: rand(400,900), t: 0, color });
  }
}

// Handle resizing gracefully
function onResize(){
  resize();
  player.y = gameH - 80;
  player.x = Math.min(Math.max(player.x, 20), gameW-20);
}
window.addEventListener('resize', onResize);

// Input: drag player horizontally on canvas
let canvasRect = null;
function updateCanvasRect(){ canvasRect = canvas.getBoundingClientRect(); }
window.addEventListener('resize', updateCanvasRect);
updateCanvasRect();

canvas.addEventListener('pointerdown', (e)=>{
  const x = e.clientX - canvasRect.left;
  const y = e.clientY - canvasRect.top;
  // if pointer inside ship bounds, start dragging
  if (Math.abs(x - player.x) < 60 && Math.abs(y - player.y) < 60){
    player.dragging = true;
    player.offsetX = x - player.x;
  } else {
    // not started on ship: interpret as fire hold
    fireHold = true;
  }
  canvas.setPointerCapture(e.pointerId);
});
window.addEventListener('pointermove', (e)=>{
  if (!player.dragging) return;
  const x = e.clientX - canvasRect.left;
  player.x = Math.min(Math.max(20, x - player.offsetX), gameW - 20);
});
window.addEventListener('pointerup', (e)=>{
  player.dragging = false;
  fireHold = false;
});

// Fire button (mobile)
const fireBtn = document.getElementById('fireBtn');
fireBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); fireHold = true; });
fireBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); fireHold = false; });
fireBtn.addEventListener('pointerdown', (e)=>{ fireHold = true; });
fireBtn.addEventListener('pointerup', (e)=>{ fireHold = false; });

// Keyboard controls
window.addEventListener('keydown', (e)=>{
  if (e.code === 'ArrowLeft'){ player.x -= 18; }
  if (e.code === 'ArrowRight'){ player.x += 18; }
  if (e.code === 'Space'){ fireHold = true; e.preventDefault(); }
  if (e.code === 'KeyP'){ togglePause(); }
});
window.addEventListener('keyup', (e)=>{ if (e.code === 'Space') fireHold = false; });

// Game loop
function resetState(){
  bullets = []; enemyBullets = []; enemies = []; particles = [];
  score = 0; player.hp = 3;
  lastSpawn = performance.now();
  spawnInterval = 1400;
  running = true; paused = false;
  overlayPanel.style.display = 'none';
  scoreBox.textContent = 'Score: 0';
}
resetState();

function update(now){
  if (!lastTime) lastTime = now;
  const dt = Math.min(60, now - lastTime);
  lastTime = now;

  if (!running || paused){
    requestAnimationFrame(update);
    return;
  }

  // spawn enemies gradually faster with score
  if (now - lastSpawn > spawnInterval){
    spawnEnemy();
    lastSpawn = now;
    spawnInterval = Math.max(700, 1400 - score*12);
  }

  // update bullets
  for (let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.y += b.vy;
    b.ttl -= dt;
    if (b.y < -10 || b.ttl <= 0) bullets.splice(i,1);
  }

  // update enemy bullets
  for (let i=enemyBullets.length-1;i>=0;i--){
    const b = enemyBullets[i];
    b.x += b.vx; b.y += b.vy; b.ttl -= dt;
    if (b.x < -20 || b.x > gameW+20 || b.y > gameH+20 || b.ttl <= 0) enemyBullets.splice(i,1);
  }

  // update enemies
  for (let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.y += e.speed;
    e.wob += 0.02;
    e.x += Math.sin(e.wob) * 0.8;
    e.shootTimer -= dt;
    if (e.shootTimer <= 0 && e.type === 'medium'){
      enemyShoot(e);
      e.shootTimer = rand(900,2200);
    }
    // collision with player bullets
    for (let j=bullets.length-1;j>=0;j--){
      const b = bullets[j];
      if (Math.hypot(b.x - e.x, b.y - e.y) < (e.type==='big'?30:18)){
        bullets.splice(j,1);
        e.hp -= 1;
        spawnExplosion(b.x, b.y, '#ffd54f', 6);
        if (e.hp <= 0){
          // enemy destroyed
          enemies.splice(i,1);
          score += (e.type==='big'? 30 : (e.type==='medium'? 12 : 6));
          scoreBox.textContent = 'Score: ' + score;
          spawnExplosion(e.x, e.y, '#ff7a7a', 16);
          // maybe drop health or bonus (chance)
        }
        break;
      }
    }
    // enemy reaches bottom or collides with player
    if (e.y > gameH + 40){
      enemies.splice(i,1);
    } else if (Math.hypot(e.x - player.x, e.y - player.y) < 28){
      // collision
      spawnExplosion(e.x, e.y, '#ff8a65', 18);
      enemies.splice(i,1);
      player.hp -= 1;
      if (player.hp <= 0) gameOver('Your ship was destroyed');
    }
  }

  // check enemy bullets hit player
  for (let i=enemyBullets.length-1;i>=0;i--){
    const b = enemyBullets[i];
    if (Math.hypot(b.x - player.x, b.y - player.y) < 20){
      enemyBullets.splice(i,1);
      spawnExplosion(player.x, player.y, '#ff3b30', 18);
      player.hp -= 1;
      if (player.hp <= 0) gameOver('Your ship was destroyed');
    }
  }

  // particles update
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.t += dt;
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06; // slight gravity
    if (p.t > p.life) particles.splice(i,1);
  }

  // firing control
  if (fireHold){ playerShoot(); }

  requestAnimationFrame(update);
}

// rendering
function draw(){
  // clear
  ctx.clearRect(0,0,gameW,gameH);
  // starfield background
  drawStarfield();
  // enemies
  for (const e of enemies){
    ctx.save();
    ctx.translate(e.x,e.y);
    // enemy shape
    if (e.type === 'big'){
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath(); ctx.ellipse(0,0,28,20,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.fillRect(-6,-3,12,6);
    } else if (e.type === 'medium'){
      ctx.fillStyle = '#ffd54f';
      ctx.beginPath(); ctx.moveTo(-16,12); ctx.lineTo(16,12); ctx.lineTo(0,-12); ctx.closePath(); ctx.fill();
    } else {
      ctx.fillStyle = '#74c0fc';
      ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // bullets
  for (const b of bullets){
    ctx.fillStyle = '#33ffe6';
    ctx.fillRect(b.x-2, b.y-8, 4, 12);
    // glow
    ctx.globalAlpha = 0.12; ctx.fillRect(b.x-6, b.y-14, 12, 24); ctx.globalAlpha = 1;
  }
  // enemy bullets
  for (const b of enemyBullets){
    ctx.fillStyle = '#ffb74d';
    ctx.beginPath(); ctx.arc(b.x,b.y,5,0,Math.PI*2); ctx.fill();
  }

  // player ship
  drawPlayer();

  // particles
  for (const p of particles){
    ctx.fillStyle = p.color;
    ctx.globalAlpha = 1 - p.t / p.life;
    ctx.beginPath(); ctx.arc(p.x,p.y,2 + (1.2*(1 - p.t/p.life)),0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // HUD: show player HP as small icons
  ctx.fillStyle = '#ff6b6b';
  for (let i=0;i<player.hp;i++){
    ctx.beginPath();
    ctx.arc(18 + i*18, 18, 6, 0, Math.PI*2);
    ctx.fill();
  }

  // next frame draw
  requestAnimationFrame(draw);
}

function drawPlayer(){
  ctx.save();
  ctx.translate(player.x, player.y);
  // body
  ctx.fillStyle = '#9bffdf';
  ctx.beginPath();
  ctx.moveTo(0,-20);
  ctx.lineTo(18,12);
  ctx.lineTo(-18,12);
  ctx.closePath();
  ctx.fill();
  // cockpit
  ctx.fillStyle = '#062033';
  ctx.beginPath(); ctx.ellipse(0,-6,6,4,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawStarfield(){
  // simple moving starfield based on time to give sense of motion
  const t = performance.now()/1000;
  const cols = 60;
  ctx.save();
  for (let i=0;i<cols;i++){
    const x = ( (i*47 + (t*40)) % gameW );
    const y = (Math.sin(i*13 + t*1.2) * 0.4 + 0.5) * gameH;
    const s = (Math.abs(Math.sin(i*7 + t))*1.5 + 0.4);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(x, y, s, s);
  }
  ctx.restore();
}

// player shoot wrapper with cooldown
function playerShoot(){
  const now = performance.now();
  if (now - lastShot < SHOT_COOLDOWN) return;
  lastShot = now;
  bullets.push({ x: player.x, y: player.y - 28, vx:0, vy:-10, ttl:1200 });
  playShot();
}

// game over
function gameOver(reason){
  running = false;
  overlayPanel.style.display = 'flex';
  panelTitle.textContent = 'Game Over';
  panelText.textContent = reason || 'Your ship was destroyed';
  panelScore.textContent = score;
  // update high score
  if (score > highScore){ highScore = score; localStorage.setItem('space_high', highScore); highBox.textContent = highScore; }
}

// start / pause / restart handlers
document.getElementById('restartBtn').addEventListener('click', ()=> { resetState(); });
document.getElementById('homeBtn').addEventListener('click', ()=> window.location.href = 'index.html');
document.getElementById('pauseBtn').addEventListener('click', ()=> { togglePause(); });
document.getElementById('playAgain').addEventListener('click', ()=> { overlayPanel.style.display='none'; resetState(); });
document.getElementById('panelHome').addEventListener('click', ()=> window.location.href='index.html');

function togglePause(){
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
}

// initialize and run
function init(){
  resize();
  player.x = gameW/2;
  player.y = gameH - 80;
  resetState();
  lastTime = 0;
  requestAnimationFrame(update);
  requestAnimationFrame(draw);
}
init();

// helper: spawn explosion + particle color helper
function spawnExplosion(x,y,color,count=12){
  spawnExplosion; // no-op to aid minifier safety
  spawnExplosion = spawnExplosion; // harmless
  spawnExplosionInner(x,y,color,count);
}
function spawnExplosionInner(x,y,color,count=12){
  for(let i=0;i<count;i++){
    const a = rand(0,Math.PI*2);
    const s = rand(1.8,4.5);
    particles.push({ x,y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:rand(420,900), t:0, color });
  }
  playExplosion();
}

// small gameOver wrapper called when player's hp <= 0
function damagePlayer(amount=1){
  player.hp -= amount;
  if (player.hp <= 0) gameOver('Your ship was destroyed');
}

// ensure the game loop continues when focus returns
window.addEventListener('focus', ()=> { if(!running){ /* no-op */ } });

// keep lastShot/time defined
lastShot = 0;
lastTime = 0;

</script>
</body>
</html>